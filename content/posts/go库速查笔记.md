---
title: go库速查笔记
date: '2024-09-16T08:11:47+08:00'
tags:
- Go
- 笔记
draft: true
hiddenFromHomePage: true
hiddenFromSearch: true
---

# go库速查笔记

因为很多库教程就几句话，单开一页太麻烦就记在一起了。

## web开发

### gorilla/websocket

`go get github.com/gorilla/websocket`

[参考](https://cloud.tencent.com/developer/article/2365666)

**Upgrader**
`Upgrader`指定用于将 HTTP 连接升级到 WebSocket 连接

```go
type Upgrader struct {
    HandshakeTimeout time.Duration
    ReadBufferSize, WriteBufferSize int
    WriteBufferPool BufferPool
    Subprotocols []string
    Error func(w http.ResponseWriter, r *http.Request, status int, reason error)
    CheckOrigin func(r *http.Request) bool
    EnableCompression bool
}
```

- `HandshakeTimeout：` 握手完成的持续时间
- `ReadBufferSize`和`WriteBufferSize`：以字节为单位指定I/O缓冲区大小。如果缓冲区大小为零，则使用HTTP服务器分配的缓冲区
- `CheckOrigin` ： 函数应仔细验证请求来源 防止跨站点请求伪造

这里一般会设置下CheckOrigin来解决跨域问题,也可以`var upgrader = websocket.Upgrader{} // use default options`使用默认配置。

**Conn**
`Conn`类型表示WebSocket连接，这个结构体的组成包括两部分，写入字段（Write fields）和 读取字段（Read  fields）

```go
type Conn struct {
 conn        net.Conn
 isServer    bool
 ...

 // Write fields
 writeBuf      []byte        
 writePool     BufferPool
 writeBufSize  int
 writer        io.WriteCloser 
 isWriting     bool           
 ...
 // Read fields
 readRemaining int64
 readFinal     bool  
 readLength    int64 
 messageReader *messageReader 
 ...
}
```

isServer  ： 字段来区分我们是否用Conn作为客户端还是服务端，也就是说说gorilla/websocket中同时编写客户端程序和服务器程序，但是一般是Web应用程序使用单独的前端作为客户端程序

**服务端示例**
以gin框架为例

```go
var upgrader = websocket.Upgrader{} // use default options

func main() {
 route := gin.Default()
 router.GET("/ws", func(c *gin.Context) {
  wsHandler(c.Writer, c.Request)
 })
 route.Run("localhost:8080")
}

func wsHandler(w http.ResponseWriter, r *http.Request) {
 //转换为升级为websocket
 conn, err := upGrader.Upgrade(w, r, nil)
 //释放连接
 defer conn.Close()

 for {
  //接收消息
  messageType, message, err := conn.ReadMessage()
  log.Println("server receive messageType", messageType, "message", string(message))
  //发送消息
  err = conn.WriteMessage(messageType, []byte("pong"))
 }
}
```

**客户端示例**
以gin框架为例

```go
 //服务器地址 websocket 统一使用 ws://
 url := "ws://localhost:8080/ws"
 //使用默认拨号器，向服务器发送连接请求
 conn, _, err := websocket.DefaultDialer.Dial(url, nil)
 //关闭连接
 defer conn.Close()
 //发送消息
 go func() {
  for {
   err := conn.WriteMessage(websocket.BinaryMessage, []byte("ping"))
   time.Sleep(time.Second * 2)
  }
 }()
 //接收消息
 for {
  _, data, err := conn.ReadMessage()
  fmt.Println("client receive message: ", string(data))
 }
```

### gorilla/session

[「Go工具箱」web中的session管理，推荐使用gorilla/sessions包](https://cloud.tencent.com/developer/article/2211987)
[Go 每日一库之 gorilla/sessions](https://darjun.github.io/2021/07/25/godailylib/gorilla/sessions/)
[Go语言中文文档](https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/Sessions.html)

几篇教程都讲的session原理还行但实现就很一般了，还是记一下。

**初始化会话仓库**：

```go
func sessions.NewFilesystemStore(path string, keyPairs ...[]byte) *sessions.FilesystemStore
```

这里使用的是本地文件存储会话为例，mysql或redis实现可以去查原项目的API。
`path`为存储路径，`keyPairs`为密钥，测试用的话随便设一个就行。

**新建/获取session**：

```go
func (s *FilesystemStore) New(r *http.Request, name string) (*Session, error)
func (s *FilesystemStore) Get(r *http.Request, name string) (*Session, error)
```

`Get`方法其实复合了`New`方法，当request中没有对应会话时返回一个新会话。name参数用来区别不同的会话，比如你要管理的是用户状态就可以用user之类。

**保存session**：

```go
func (s *FilesystemStore) Save(r *http.Request, w http.ResponseWriter, session *Session) error
```

这个方法同时将会话保存到本地和request。

**操作session**：

session的定义如下：

```go
type Session struct {
 // The ID of the session, generated by stores. It should not be used for
 // user data.
 ID string
 // Values contains the user-data for the session.
 Values  map[interface{}]interface{}
 Options *Options
 IsNew   bool
 // contains filtered or unexported fields
}
```

关于`Session.ID`，它说是说会由store自动生成，可是我试了无论是`Store.New()`方法还是`sessions.NewSession()`方法生成的session的ID都是空的。所以还是建议手动赋值一个id，可以使用`jakehl/goid`生成一个uuid。

要为session赋值或者从session中取出值，只需要操作`session.Values`就行，例如：

```go
session, err := Store.New(ctx.Request, "user")
session.Values["userid"]=123  // 赋值
userid = session.Values["userid"]  // 取值
```

**删除session**：

将session的过期时间设置为-1即可，store将自动从本地删除session，同时清空request里的session。

```go
session.Options.MaxAge = -1
```

### gin-contrib/sessions

[Golang中文学习文档](https://golang.halfiisland.com/community/pkgs/web/gin.html#session)
[Gin 框架之Cookie与Session](https://cloud.tencent.com/developer/article/2381258)

### go-resty/resty/v2

restful http 客户端

[Go 每日一库之 resty](https://darjun.github.io/2021/06/26/godailylib/resty/)

## 数据验证

### asaskevich/govalidator

验证器
[Go每日一库之82：govalidator](https://juejin.cn/post/7289249524325711908)

### go-playground/validator/v10

另一个验证器，刚开始把这两个搞混了。
gin 框架的默认验证器
[Validator | Go中文学习文档](https://golang.halfiisland.com/community/pkgs/validate/Validator.html)
[Go 验证器 validator 详解](https://learnku.com/articles/78391)

## 配置管理

### viper

[viper](https://github.com/spf13/viper)

[Golang中文学习文档](https://golang.halfiisland.com/community/pkgs/config/Viper.html)

基本用法如下：

**设置默认值**：

`viper.SetDefault(key,value)`

**读取配置文件**：

```go
viper.SetConfigName("config.yml") // 读取名为config的配置文件，没有设置特定的文件后缀名
viper.SetConfigType("yaml")       // 当没有设置特定的文件后缀名时，必须要指定文件类型
viper.AddConfigPath("./")         // 在当前文件夹下寻找
viper.AddConfigPath("$HOME/")     // 使用变量
viper.AddConfigPath(".")          // 在工作目录下查找
err := viper.ReadInConfig() //读取配置
```

**访问配置方法**：

- `Get(key string) : interface{}`
- `GetBool(key string) : bool`
- `GetFloat64(key string) : float64`
- `GetInt(key string) : int`
- `GetIntSlice(key string) : []int`
- `GetString(key string) : string`
- `GetStringMap(key string) : map[string]interface{}`
- `GetStringMapString(key string) : map[string]string`
- `GetStringSlice(key string) : []string`
- `GetTime(key string) : time.Time`
- `GetDuration(key string) : time.Duration`
- `IsSet(key string) : bool`
- `AllSettings() : map[string]interface{}`

当访问嵌套配置的时候通过.分隔符进行访问，例如`GetString("server.database.url")`。

进阶用法详见文档。

## 日志库

### logrus

[logrus](https://github.com/sirupsen/logrus)

顺手记一下。

### zap

- [zap](https://github.com/uber-go/zap)
- [Golang中文学习文档](https://golang.halfiisland.com/community/pkgs/logs/Zap.html)
- [Go语言中文文档](https://www.topgoer.com/%E9%A1%B9%E7%9B%AE/log/ZapLogger.html)
第二个教程更好理解。

zap有sugar和logger两种写法。sugar支持printf风格但性能相对较低。这里以logger为例。

**快速入门**：

```go
logger, err := zap.NewProduction()
if err != nil {
 log.Fatalf("Error creating logger: %v", err)
}
defer logger.Sync() 
```

这样就创建了一个最基础的logger，把日志写入到标准输出。语法如下：
`func (log *Logger) MethodXXX(msg string, fields ...Field)`
MethodXXX是方法名,即Info/Error/Debug/Panic等，msg是日志内容，fields是一些额外的信息，比如时间戳、日志级别、错误信息等。每个zapcore.Field其实就是一组键值对参数。

**高级配置**：

可以通过`zap.New(core)`方法自定义配置，需要先创建一个core。

```go
core := zapcore.NewCore(encoder, writer, level)
logger := zap.New(core)
```

`encoder`：编码器(如何写入日志)
`writer`：指定日志将写入的地方
`level`：指定日志级别

JSON Encoder：`zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())`
Console Encoder：`zapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig())`

写入文件：`zapcore.AddSync(file)`
多重写入：`zapcore.NewMultiWriteSyncer(zapcore.AddSync(os.Stdout), zapcore.AddSync(file))`

level使用默认值就行 `zapcore.InfoLevel`

## 认证鉴权

### casbin

[casbin](https://casbin.org/docs/overview)

### jwt

[jwt](https://pkg.go.dev/github.com/golang-jwt/jwt/v5)

教程：
[Golang中文学习文档](https://golang.halfiisland.com/community/pkgs/auth/jwt.html)

**JWT结构**：

在RFC标准中，JWT由`Header` 头部,`Payload` 载荷,`Signature` 签名组成一个字符串，格式就是`header.payload.signature`，这就是一个JWT令牌的标准结构。
头部只是声明一些基本信息，通常由两部分组成，令牌的类型，和签名所使用的加密算法。
JWT的第二部分是载荷部分，主要包含声明(claims)部分，声明部分通常是关于一个实体的数据，比如一个用户。
在获得了编码的头部和编码的载荷部分后，就可以通过头部所指明的签名算法根据前两个部分的内容再加上密钥进行加密签名，所以一旦JWT的内容有任何变化，解密时得到的签名都会不一样。

这里以HMAC对称加密为示例，使用类型[]byte的值用于签名和验证。

**创建与签名token**：

`func NewWithClaims(method SigningMethod, claims Claims) *Token`

其中`method`是签名方法，`claims`是载荷部分，返回一个`Token`结构体。

claims可以使用预定义的`jwt.RegisteredClaims`，也可以使用`jwt.MapClaims`快捷定义，本质是一个`map[string]interface{}`。又或者自定义一个Claims结构体，将预定义的`jwt.RegisteredClaims`作为匿名字段嵌入，从而实现扩展。

```go
secret := []byte("my secret")
token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
 "username": "admin",
 "password": "123456",
 "role": "admin",
})
tokenString, err := token.SignedString(secret)
```

**解析token与错误处理**：

```go
// 传入token字符串和验证钩子函数，返回值就是一个Token结构体
token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
    // 验证签名算法是否匹配
    if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
        return nil, fmt.Errorf("不匹配的签名算法: %s", token.Header["alg"])
    }
    // 返回验证密钥
    return secret, nil
})

if token.Valid {
    fmt.Println("token合法")
} else if errors.Is(err, jwt.ErrTokenMalformed) {
    fmt.Println("传入的字符串甚至连一个token都不是...")
} else if errors.Is(err, jwt.ErrTokenExpired) || errors.Is(err, jwt.ErrTokenNotValidYet) {
    fmt.Println("token已经过期或者还没有生效")
} else {
    fmt.Println("token处理异常...")
}
```

**自定义Claim解析**：

```go
token, err := jwt.ParseWithClaims(tokenstring, &MyClaims{}, func(token *jwt.Token) (interface{}, error) {
    return secret, nil
}, jwt.WithValidMethods([]string{"HS256"})) // 使用option进行验证

// 类型断言
if claims, ok := token.Claims.(*MyClaims); ok && token.Valid {
    fmt.Println(claims)
} else {
    fmt.Println(err)
}
```

**注意**：使用自定义Claim需要定义一系列方法来实现`jwt.Claims`接口。

## 图像界面

还没决定学哪个包。

### fyne

[fyne](https://github.com/fyne-io/fyne)

Go跨平台GUI工具包
看起来很不错，大概会选择这个包。

### Gio UI

[gio](https://gioui.org/)

听说不错但是文档太少了，而且没有中文文档，看起来比较劝退。

### govcl

[govcl](https://github.com/ying32/govcl)

中文支持很好，但star数太少。

### andlabs/ui

[andlabs/ui](https://github.com/andlabs/ui)

应该是个比较轻量的包，有空看看。

## UUID

### google/uuid

`github.com/google/uuid`

```go
uuid := uuid.New()
fmt.Println(uuid)
```

## 安卓相关

### avast/apkverifier

[apkverifier](https://pkg.go.dev/github.com/avast/apkverifier)

用的这个

[apksign](https://pkg.go.dev/github.com/morrildl/playground-android/apksign)

犄角旮旯里翻出来的，没用过，记一下

[test-apks](https://github.com/obfusk/test-apks/tree/master)

测试用的安装包

## 文件处理

### archive/zip

[archive/zip](https://pkg.go.dev/archive/zip)

压缩解压,go的标准库

**解压**：

使用`reader,err := zip.OpenReader(path)`打开压缩包，之后遍历`_, file := range reader.File`，就可以正常使用文件句柄file。如果需要解压文件出来，就新建文件后复制过去。

**压缩**：

首先新建空文件，用`zipWriter, err := zip.NewWriter(path)`方法打开。对需要压缩的文件，打开后用`info, err := file.Stat()`方法获取文件信息，`header, err := zip.FileInfoHeader(info)`方法转换成文件头，`fileWriter, err := zipWriter.CreateWriter(header)`方法转换成压缩包内的写入接口，最后`io.Copy(fileWriter, file)`复制文件进去。

## 静态检查

### staticcheck

[staticcheck](https://github.com/dominikh/go-tools)

### golangci-lint

[golangci-lint](https://github.com/golangci/golangci-lint)

### NilAway

[NilAway](https://github.com/uber-go/nilaway)
