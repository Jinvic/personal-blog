---
title: 《Go语言高级编程》阅读笔记
date: '2025-07-26T09:33:11+08:00'
tags: 
categories: 
draft: true
hiddenFromHomePage: false
hiddenFromSearch: false
---

# 《Go语言高级编程》阅读笔记

一直以来看书学习什么的都是选择的入门书籍，一边复习基础知识一边了解细节，只有最后的几章会比较深入。感觉比起这种查漏补缺式的基础学习，我现在想要进一步提升的话更需要了解一些深入的知识，所以选择了本书。当然，也没要从头到尾完整啃一遍，毕竟很多东西学了暂时用不上没有实践巩固相当于白学。所以只读用得上和感兴趣的章节。

## 1. 语言基础

### 1.1 GO语言创世纪

go语言发展历程的历史介绍。主要介绍Go的并发特性是如何演变的。

### 1.2 Hello, World 的革命

带着代码进一步介绍各语言的演变。最后重点介绍Go语言的演变。

说实话，C和Go以外的语言都看不懂，但也不需要看懂，了解一下就行。

### 1.3 数组、字符串和切片

在Go中，数组、字符串和切片的底层内存结构是一致的，但上层具体实现各不相同，本章则深入底层进行详细讲解。

#### 1.3.1 数组

数组的长度是数组类型的组成部分。所以**不同长度**或不同类型的数据组成的数组都是不同的类型，无法直接赋值。所以Go中很少直接使用数组，而是更为灵活的切片。不过了解数组有助于我们进一步理解切片。

```go
var a [3]int                    // 定义长度为 3 的 int 型数组, 元素全部为 0
var b = [...]int{1, 2, 3}       // 定义长度为 3 的 int 型数组, 元素为 1, 2, 3
var c = [...]int{2: 3, 1: 2}    // 定义长度为 3 的 int 型数组, 元素为 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6} // 定义长度为 6 的 int 型数组, 元素为 1, 2, 0, 0, 5, 6
```

如上是数组可选的定义方式，如下对各种方式进行解释。

1. 指定长度并将每个元素初始化为零值。
2. 定义时初始化全部元素，长度自动计算。
3. 按索引初始化指定元素，为指定元素初始化为零值，长度取决于最大索引。
4. 结合23，按索引从不同位置开始顺序初始化若干个元素。

>Go 语言中数组是**值语义**。一个数组变量即表示整个数组，它并**不是隐式的指向第一个元素的指针**（比如 C 语言的数组），而是一个完整的值。

这里提到可以使用空数组避免占用内存空间，例如`[0]int`。不过更常见的做法还是使用`struct{}{}`。

#### 1.3.2 字符串

一个字符串是一个**不可改变**的字节序列，通常是用来包含人类可读的文本数据。和数组不同的是，字符串的元素不可修改，是一个只读的字节数组。

Go 语言字符串的底层结构在 `reflect.StringHeader` 中定义：

```go
type StringHeader struct {
    Data uintptr
    Len  int
}
```

字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。字符串其实是一个结构体，因此字符串的赋值操作也就是 `reflect.StringHeader` 结构体的复制过程，并不会涉及底层字节数组的复制。

Go 语言对字符串和 `[]rune` 类型的相互转换提供了特殊的支持。`rune` 用于表示每个 `Unicode` 码点 只是 `int32` 类型的别名，并不是重新定义的类型。

最后提供了 `string`, `[]byte`, `[]rune` 各种类型的模拟转换方式，想深入底层进一步了解可以看看。

### 1.3.3 切片(slice)

我们先看看切片的结构定义，`reflect.SliceHeader`：

```go
type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
```

相比数组，切片多了一个 Cap 成员表示切片指向的内存空间的最大容量（对应元素的个数，而不是字节数）。

和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。

**添加切片元素**：

内置的泛型函数 append 可以在切片的尾部追加 N 个元素。

在容量不足的情况下，append 的操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用 append 函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。

除了在切片的尾部追加，我们还可以在切片的开头添加元素，但一般都会导致内存的重新分配，而且会导致已有的元素全部复制 1 次，所以性能会差很多。

可以用 `copy` 和 `append` 组合可以避免创建中间的临时切片：

```go
// 添加到末尾
a = append(a, 0)     // 切片扩展 1 个空间
copy(a[i+1:], a[i:]) // a[i:] 向后移动 1 个位置
a[i] = x             // 设置新添加的元素

// 添加到中间
a = append(a, x...)       // 为 x 切片扩展足够的空间
copy(a[i+len(x):], a[i:]) // a[i:] 向后移动 len(x) 个位置
copy(a[i:], x)            // 复制新添加的切片
```

**删除切片元素**：

删除操作也可以用 `copy` 或者 `append` 避免移动数据指针。如果有C语言基础的话比较容易理解，和C的数组操作类似。

```go
// 从尾部删除
a = []int{1, 2, 3}
a = a[:len(a)-1]   // 删除尾部 1 个元素
a = a[:len(a)-N]   // 删除尾部 N 个元素

// 从头部删除
a = []int{1, 2, 3}
a = a[1:] // 删除开头 1 个元素
a = a[N:] // 删除开头 N 个元素

a = append(a[:0], a[1:]...) // 删除开头 1 个元素
a = append(a[:0], a[N:]...) // 删除开头 N 个元素

a = a[:copy(a, a[1:])] // 删除开头 1 个元素
a = a[:copy(a, a[N:])] // 删除开头 N 个元素

// 从中间删除
a = []int{1, 2, 3, ...}

a = append(a[:i], a[i+1:]...) // 删除中间 1 个元素
a = append(a[:i], a[i+N:]...) // 删除中间 N 个元素

a = a[:i+copy(a[i:], a[i+1:])]  // 删除中间 1 个元素
a = a[:i+copy(a[i:], a[i+N:])]  // 删除中间 N 个元素
```

**切片内存技巧**：

在判断一个切片是否为空时，一般通过 len 获取切片的长度来判断，而不是直接和nil比较。

在原切片上声明0长切片可以直接服用原切片的内存和容量，减少内存分配，提高性能。

```go
// e.g. 根据条件过滤
func Filter(s []byte, fn func(x byte) bool) []byte {
    b := s[:0]
    for _, x := range s {
        if !fn(x) {
            b = append(b, x)
        }
    }
    return b
}
```

**避免切片内存泄漏**：

这里给出了两个例子，一个是切片引用了原始数组导致GC无法回收，解决方法是复制数据到新切片返回：

```go
// 错误：直接返回引用了文件的切片
func FindPhoneNumber(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return regexp.MustCompile("[0-9]+").Find(b)
}

// 正确：复制到新切片
func FindPhoneNumber(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = regexp.MustCompile("[0-9]+").Find(b)
    return append([]byte{}, b...)
}
```

另一个例子是对于指针切片，删除一个元素后被删除的元素依然被切片引用，其内存不会被GC回收：

```go
// 错误
var a []*int{ ... }
a = a[:len(a)-1]    // 被删除的最后一个元素依然被引用, 可能导致 GC 操作被阻碍

// 正确
var a []*int{ ... }
a[len(a)-1] = nil // GC 回收最后一个元素内存
a = a[:len(a)-1]  // 从切片删除最后一个元素

```

如果切片生命周期很短，不用刻意处理这个问题。GC回收切片时会回收所有元素。

**切片类型强制转换**:

为了安全，当两个切片类型 []T 和 []Y 的底层原始切片类型不同时，Go 语言是无法直接转换类型的。不过也可以通过`unsafe`和`reflect`等包进行更底层的操作，这时的语法就更像C了。

示例略，有需要再看。需要一定的前置知识，而`reflect`和`unsafe`包我都只有简单了解，平时基本用不上。
